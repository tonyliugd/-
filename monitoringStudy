#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Time    : 2025/5/22 20:43
@Author  : YourName
@File    : 46.py
@Desc    : 
"""
# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Time    : 2025/5/22 17:07
@Author  : YourName
@File    : 40.py
@Desc    : 儿童学习监控系统（完整版本）
"""
import cv2
import time
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, scrolledtext
from datetime import datetime, timedelta
import pygame
from PIL import Image, ImageTk
from collections import Counter
import threading
import queue
from threading import Lock
import numpy as np
import os
import subprocess
import logging
import platform
import mediapipe as mp  # 新增MediaPipe依赖


class StudyMonitor:
    def __init__(self):
        # 初始化日志系统
        self.setup_logging()
        self.logger.info("启动儿童学习监控系统")

        # 先初始化摄像头锁
        self.camera_lock = Lock()  # 摄像头操作锁

        # 检测可用摄像头
        self.available_cameras = self.detect_available_cameras()
        if not self.available_cameras:
            self.update_status("未检测到可用摄像头，请检查设备连接")

        # 程序核心状态
        self.is_running = False
        self.person_detected = False
        self.studying = False
        self.last_study_time = time.time()
        self.alert_threshold = 300  # 5分钟未学习触发提醒（秒）
        self.study_duration = 0  # 当前会话学习时长
        self.total_study_time = 0  # 今日总学习时长
        self.idle_duration = 0  # 未学习时长
        self.start_time = None
        self.current_session_start = None

        # 摄像头管理
        self.cap = None
        self.current_camera_id = 0
        self.width, self.height = 640, 480
        self.camera_initialized = False
        self.camera_attempts = 0
        self.max_camera_attempts = 3

        # 线程和队列管理
        self.frame_queue = queue.Queue(maxsize=3)  # 减少队列大小，降低内存占用
        self.hand_queue = queue.Queue(maxsize=1)  # 手部检测结果队列
        self.processing_thread = None
        self.hand_thread = None
        self.is_capturing = False
        self.time_lock = Lock()  # 时间同步锁
        self.gui_update_event = threading.Event()  # GUI更新事件

        # 性能优化参数
        self.frame_skip = 2  # 每处理1帧，跳过2帧
        self.current_frame_count = 0

        # 手部检测优化
        self.hand_detection_interval = 10  # 每10帧检测一次手部
        self.last_hand_detection = 0

        # 人脸识别模型
        self.face_cascade = None
        self.eye_cascade = None

        # 手部检测模型（使用MediaPipe）
        self.mp_hands = mp.solutions.hands
        self.hands = self.mp_hands.Hands(
            max_num_hands=1,  # 只检测一只手，提高性能
            min_detection_confidence=0.8,  # 提高检测置信度阈值
            min_tracking_confidence=0.5
        )
        self.hand_landmarks = None
        self.hand_history = []
        self.min_writing_points = 5
        self.writing_threshold = 80
        self.hand_detection_retries = 0
        self.max_retries = 3

        # 手部检测优化参数
        self.hand_detection_enabled = False
        self.hand_detection_regions = []
        self.setup_detection_region()

        # 学科识别配置
        self.subject_detection_enabled = False
        self.current_subject = "未识别"
        self.subject_history = []
        self.subject_keywords = {
            "数学": ["数学", "方程", "函数", "几何", "计算"],
            "语文": ["汉字", "作文", "阅读", "古诗", "文言文"],
            "英语": ["English", "单词", "语法", "阅读", "writing"],
            "物理": ["力学", "运动", "能量", "光学", "电学"],
            "化学": ["元素", "反应", "方程式", "实验", "分子"],
            "生物": ["细胞", "基因", "进化", "生态", "DNA"],
            "编程": ["代码", "算法", "变量", "循环", "函数"],
            "历史": ["朝代", "事件", "人物", "年代", "史料"],
            "地理": ["地图", "气候", "地形", "国家", "资源"],
            "音乐": ["音符", "乐器", "乐谱", "节奏", "和弦"],
            "美术": ["绘画", "色彩", "构图", "雕塑", "设计"],
            "体育": ["运动", "比赛", "健身", "训练", "规则"]
        }
        self.manual_subject = "未选择"

        # 提醒系统配置
        self.alert_messages = []
        self.max_alert_history = 20
        self.message_interval = 300  # 提醒间隔（秒）
        self.last_alert_time = 0
        self.last_alert_check_time = time.time()

        # 窗口管理
        self.camera_window = None
        self.camera_window_label = None
        self.camera_window_open = False

        # 本地大模型配置
        self.llm_available = False
        self.llm_model = None
        self.llm_thread = None
        self.llm_queue = queue.Queue()

        # 学习数据记录
        self.study_sessions = []  # 存储学习会话记录
        self.daily_study_data = {}  # 按日期存储学习数据

        # 加载历史数据
        self.load_study_data()

        # 初始化GUI
        pygame.init()
        self.create_gui()
        self.setup_styles()

        # 更新状态
        self.update_status("系统已启动，请点击开始监控")

        # 加载人脸检测器
        self.load_face_detectors()

    def setup_logging(self):
        """设置日志系统"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler("study_monitor.log"),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger("StudyMonitor")

    def detect_available_cameras(self):
        """检测可用摄像头并返回有效索引列表"""
        cameras = []
        self.logger.info("正在检测可用摄像头...")

        # 尝试不同的方法检测摄像头
        methods = [
            self._detect_cameras_opencv,
            self._detect_cameras_linux,
            self._detect_cameras_windows,
            self._detect_cameras_macos
        ]

        for method in methods:
            try:
                detected = method()
                if detected:
                    cameras.extend(detected)
                    cameras = list(set(cameras))
                    break
            except Exception as e:
                self.logger.warning(f"使用{method.__name__}检测摄像头时出错: {str(e)}")

        if not cameras:
            self.logger.warning("未发现可用摄像头")

        return cameras

    def _detect_cameras_opencv(self):
        """使用OpenCV直接检测摄像头"""
        cameras = []
        for i in range(10):
            try:
                with self.camera_lock:
                    cap = cv2.VideoCapture(i)
                    if cap.isOpened():
                        ret, frame = cap.read()
                        if ret:
                            cameras.append(i)
                            self.logger.info(f"摄像头 {i} 可用")
                        cap.release()
            except Exception as e:
                self.logger.warning(f"检测摄像头 {i} 时出错: {e}")

        return cameras

    def _detect_cameras_linux(self):
        """在Linux系统上检测摄像头"""
        if platform.system() != "Linux":
            return []

        cameras = []
        try:
            for i in range(10):
                device = f"/dev/video{i}"
                if os.path.exists(device):
                    cameras.append(i)
                    self.logger.info(f"在Linux上发现摄像头: {device}")
        except Exception as e:
            self.logger.warning(f"在Linux上检测摄像头时出错: {e}")

        return cameras

    def _detect_cameras_windows(self):
        """在Windows系统上检测摄像头"""
        if platform.system() != "Windows":
            return []

        cameras = []
        try:
            # 使用命令行工具检测摄像头
            result = subprocess.run(
                ["powershell", "-Command", "Get-PnpDevice | Where-Object {$_.Class -eq 'Camera'}"],
                capture_output=True,
                text=True
            )

            if result.stdout:
                lines = result.stdout.strip().split('\n')
                for i, line in enumerate(lines):
                    if "Status" in line and "OK" in line:
                        cameras.append(i)
                        self.logger.info(f"在Windows上发现摄像头: {line.strip()}")
        except Exception as e:
            self.logger.warning(f"在Windows上检测摄像头时出错: {e}")

        return cameras

    def _detect_cameras_macos(self):
        """在macOS系统上检测摄像头"""
        if platform.system() != "Darwin":
            return []

        cameras = []
        try:
            # 使用命令行工具检测摄像头
            result = subprocess.run(
                ["system_profiler", "SPCameraDataType"],
                capture_output=True,
                text=True
            )

            if result.stdout:
                lines = result.stdout.strip().split('\n')
                for i, line in enumerate(lines):
                    if "摄像头" in line or "Camera" in line:
                        cameras.append(i)
                        self.logger.info(f"在macOS上发现摄像头: {line.strip()}")
        except Exception as e:
            self.logger.warning(f"在macOS上检测摄像头时出错: {e}")

        return cameras

    def connect_camera(self, camera_id=None):
        """连接摄像头"""
        self.logger.info(f"尝试连接摄像头 {camera_id if camera_id is not None else '默认'}")

        self.stop_capture()
        self.release_camera()

        try:
            if camera_id is None:
                if not self.available_cameras:
                    raise ValueError("没有可用的摄像头")
                camera_id = self.available_cameras[0]

            with self.camera_lock:
                self.cap = cv2.VideoCapture(camera_id)
                if not self.cap.isOpened():
                    raise ValueError(f"无法打开摄像头 {camera_id}")

                self.width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                self.height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                self.current_camera_id = camera_id
                self.update_status(f"已连接摄像头 {camera_id} ({self.width}x{self.height})")

                # 设置摄像头参数，提高性能
                self.cap.set(cv2.CAP_PROP_FPS, 30)
                self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)

                ret, frame = self.cap.read()
                if not ret or frame is None:
                    raise RuntimeError("无法从摄像头获取画面")

            self.camera_initialized = True
            self.camera_attempts = 0
            return True

        except Exception as e:
            self.camera_attempts += 1
            error_msg = f"连接摄像头失败 ({self.camera_attempts}/{self.max_camera_attempts}): {str(e)}"
            self.update_status(error_msg)
            self.logger.error(error_msg)
            self.camera_initialized = False

            if self.camera_attempts < self.max_camera_attempts:
                retry_msg = f"正在尝试重新连接摄像头 ({self.camera_attempts}/{self.max_camera_attempts})"
                self.update_status(retry_msg)
                self.root.after(1000, lambda: self.connect_camera(camera_id))
            return False

    def release_camera(self):
        """安全释放摄像头资源"""
        with self.camera_lock:
            if self.cap:
                try:
                    self.cap.release()
                    self.cap = None
                    self.logger.info("摄像头资源已释放")
                except Exception as e:
                    error_msg = f"释放摄像头资源时出错: {e}"
                    self.logger.error(error_msg)
                    self.cap = None

    def start_capture(self):
        """开始捕获帧的线程"""
        if self.is_capturing or not self.cap or not self.cap.isOpened():
            return

        self.is_capturing = True
        self.processing_thread = threading.Thread(
            target=self._capture_and_check,
            daemon=True
        )
        self.processing_thread.start()

        self.hand_thread = threading.Thread(
            target=self._hand_detection_worker,
            daemon=True
        )
        self.hand_thread.start()

        self.logger.info("开始捕获视频帧")

    def stop_capture(self):
        """停止捕获帧的线程"""
        self.is_capturing = False
        self.gui_update_event.clear()
        if self.processing_thread and self.processing_thread.is_alive():
            self.processing_thread.join(timeout=1.0)

        if self.hand_thread and self.hand_thread.is_alive():
            self.hand_thread.join(timeout=1.0)

        # 清空队列
        with self.frame_queue.mutex:
            self.frame_queue.queue.clear()

        with self.hand_queue.mutex:
            self.hand_queue.queue.clear()

    def _capture_and_check(self):
        """捕获帧并周期性检查提醒"""
        last_frame_time = time.time()
        self.logger.info("视频捕获线程已启动")

        while self.is_capturing:
            try:
                if not self.cap or not self.cap.isOpened():
                    error_msg = "摄像头连接丢失，正在尝试重新连接..."
                    self.update_status(error_msg)
                    self.logger.warning(error_msg)
                    self.camera_initialized = False
                    self.connect_camera()
                    time.sleep(1)
                    continue

                # 控制帧率
                current_time = time.time()
                if current_time - last_frame_time < 0.03:  # 约30FPS
                    time.sleep(0.005)
                    continue

                last_frame_time = current_time

                with self.camera_lock:
                    ret, frame = self.cap.read()

                if not ret:
                    error_msg = "无法从摄像头读取帧，尝试重新连接"
                    self.update_status(error_msg)
                    self.logger.warning(error_msg)
                    self.camera_initialized = False
                    self.connect_camera()
                    time.sleep(1)
                    continue

                # 帧跳过优化
                self.current_frame_count += 1
                if self.current_frame_count % (self.frame_skip + 1) != 0:
                    continue

                # 如果队列已满，丢弃旧帧
                if self.frame_queue.full():
                    try:
                        self.frame_queue.get_nowait()
                        self.logger.debug("帧队列已满，丢弃旧帧")
                    except queue.Empty:
                        pass

                self.frame_queue.put(frame)
                self.gui_update_event.set()

                # 每1秒检查一次提醒
                if time.time() - self.last_alert_check_time > 1:
                    self.check_idle_alert()
                    self.last_alert_check_time = time.time()

            except Exception as e:
                error_msg = f"捕获线程错误: {e}"
                self.logger.error(error_msg)
                time.sleep(0.1)

        self.logger.info("视频捕获线程已停止")

    def _hand_detection_worker(self):
        """独立线程处理手部检测"""
        while self.is_capturing:
            try:
                if not self.frame_queue.empty():
                    # 手部检测间隔优化
                    if self.current_frame_count % self.hand_detection_interval != 0:
                        continue

                    frame = self.frame_queue.get()
                    small_frame = cv2.resize(frame, (320, 240))

                    if self.hand_detection_regions:
                        x, y, w, h = self.hand_detection_regions[0]
                        scale_x = 320 / self.width
                        scale_y = 240 / self.height
                        roi = small_frame[int(y * scale_y):int((y + h) * scale_y),
                              int(x * scale_x):int((x + w) * scale_x)]
                        if roi.size > 0:
                            results = self.hands.process(cv2.cvtColor(roi, cv2.COLOR_BGR2RGB))
                            self.hand_queue.put((results, x, y, scale_x, scale_y))
                        else:
                            self.hand_queue.put((None, 0, 0, 1, 1))
                    else:
                        results = self.hands.process(cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB))
                        self.hand_queue.put((results, 0, 0, 1, 1))
            except Exception as e:
                self.logger.error(f"手部检测线程错误: {e}")

    def detect_person(self, frame):
        """检测人脸和眼睛"""
        if frame is None or self.face_cascade is None or self.eye_cascade is None:
            return frame

        try:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            faces = self.face_cascade.detectMultiScale(gray, 1.1, 4)

            if len(faces) > 0:
                self.person_detected = True
                for (x, y, w, h) in faces:
                    cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)
                    face_roi = gray[y:y + h, x:x + w]

                    eyes = self.eye_cascade.detectMultiScale(face_roi)
                    if len(eyes) >= 1:
                        for (ex, ey, ew, eh) in eyes:
                            cv2.rectangle(frame, (x + ex, y + ey), (x + ex + ew, y + ey + eh), (0, 255, 0), 2)
            else:
                self.person_detected = False
        except Exception as e:
            error_msg = f"人脸检测错误: {e}"
            self.logger.error(error_msg)
            self.person_detected = False

        return frame

    def detect_writing(self, frame):
        """检测手部并判断学习状态"""
        if not self.person_detected or frame is None:
            self.studying = False
            return frame

        try:
            if not self.hand_queue.empty():
                results, roi_x, roi_y, scale_x, scale_y = self.hand_queue.get()

                self.hand_landmarks = None
                self.studying = False

                if results and results.multi_hand_landmarks:
                    hand_landmarks = results.multi_hand_landmarks[0]
                    self.hand_landmarks = hand_landmarks
                    self._update_hand_history(roi_x, roi_y, scale_x, scale_y)
                    self.studying = self._detect_writing_action()

                    # 绘制手部关键点
                    mp.solutions.drawing_utils.draw_landmarks(
                        frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS
                    )

                    self.hand_detection_retries = 0
                else:
                    self.hand_detection_retries += 1
                    if self.hand_detection_retries > self.max_retries:
                        self.studying = False
                        self.hand_detection_retries = 0

            # 绘制检测区域
            for x, y, w, h in self.hand_detection_regions:
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)
                cv2.putText(frame, "Writing Area", (x + 5, y + 20),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

            # 更新学习状态
            if self.studying:
                self.last_study_time = time.time()
                cv2.putText(frame, "Studying", (10, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            else:
                cv2.putText(frame, "Not Studying", (10, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

        except Exception as e:
            error_msg = f"手部检测错误: {e}"
            self.logger.error(error_msg)
            self.studying = False

        return frame

    def _update_hand_history(self, roi_x=0, roi_y=0, scale_x=1, scale_y=1):
        """更新手部关键点历史"""
        if self.hand_landmarks:
            index_finger = self.hand_landmarks.landmark[self.mp_hands.HandLandmark.INDEX_FINGER_TIP]
            thumb = self.hand_landmarks.landmark[self.mp_hands.HandLandmark.THUMB_TIP]

            x = int((index_finger.x * 320 / scale_x) + roi_x)
            y = int((index_finger.y * 240 / scale_y) + roi_y)

            grip_distance = self._calculate_grip_distance(index_finger, thumb)

            self.hand_history.append((time.time(), x, y, grip_distance))

            # 保留最近1秒内的点
            self.hand_history = [point for point in self.hand_history
                                 if time.time() - point[0] < 1.0]

    def _calculate_grip_distance(self, index_finger, thumb):
        """计算食指与拇指的距离"""
        dx = index_finger.x - thumb.x
        dy = index_finger.y - thumb.y
        return np.sqrt(dx ** 2 + dy ** 2)

    def _detect_writing_action(self):
        """基于MediaPipe的书写动作检测"""
        if len(self.hand_history) < self.min_writing_points:
            return False

        # 计算平均移动速度
        timestamps = [p[0] for p in self.hand_history]
        xs = [p[1] for p in self.hand_history]
        ys = [p[2] for p in self.hand_history]
        total_time = timestamps[-1] - timestamps[0]
        if total_time < 0.1:
            return False

        total_distance = sum(np.hypot(xs[i] - xs[i - 1], ys[i] - ys[i - 1])
                             for i in range(1, len(xs)))
        avg_speed = total_distance / total_time

        # 判断书写条件
        grip_distance = np.mean([p[3] for p in self.hand_history])
        return (grip_distance < 0.15 and
                5 < avg_speed < self.writing_threshold)

    def identify_subject(self, frame):
        """学科识别"""
        if not self.subject_detection_enabled or frame is None:
            return

        self.current_subject = self.manual_subject
        self.subject_history.append(self.current_subject)

        if len(self.subject_history) > 10:
            self.subject_history.pop(0)

    def select_subject(self):
        """手动选择学科"""
        subjects = list(self.subject_keywords.keys())
        subjects.append("未识别")

        dialog = tk.Toplevel(self.root)
        dialog.title("选择学科")
        dialog.geometry("300x300")
        dialog.resizable(False, False)
        dialog.transient(self.root)
        dialog.grab_set()

        frame = ttk.Frame(dialog, padding=10)
        frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(frame, text="请选择当前学习的学科:", font=("Arial", 12)).pack(pady=10)

        subject_var = tk.StringVar()
        subject_var.set(self.manual_subject if self.manual_subject in subjects else "未识别")

        for subject in subjects:
            ttk.Radiobutton(
                frame,
                text=subject,
                variable=subject_var,
                value=subject
            ).pack(anchor=tk.W, pady=5)

        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=20)

        ttk.Button(
            button_frame,
            text="确定",
            command=lambda: self._set_subject(subject_var.get(), dialog)
        ).pack(side=tk.LEFT, padx=5)

        ttk.Button(
            button_frame,
            text="取消",
            command=dialog.destroy
        ).pack(side=tk.LEFT, padx=5)

        dialog.bind("<Return>", lambda event: self._set_subject(subject_var.get(), dialog))
        dialog.bind("<Escape>", lambda event: dialog.destroy())

        dialog.mainloop()

    def _set_subject(self, subject, dialog):
        """设置选择的学科"""
        self.manual_subject = subject
        self.current_subject = subject
        self.update_status(f"已设置学科: {subject}")
        dialog.destroy()

    def select_detection_region(self):
        """通过鼠标拖动选择检测区域"""
        if not self.cap or not self.cap.isOpened():
            messagebox.showwarning("提示", "请先连接摄像头")
            return

        self.roi_window = tk.Toplevel(self.root)
        self.roi_window.title("选择书写区域")
        self.roi_window.geometry(f"{self.width}x{self.height + 50}")  # 增加高度以容纳按钮
        self.roi_window.resizable(False, False)
        self.roi_window.transient(self.root)

        self.roi_canvas = tk.Canvas(self.roi_window, width=self.width, height=self.height)
        self.roi_canvas.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.roi_start = None
        self.roi_end = None
        self.roi_rect = None

        self.roi_canvas.bind("<Button-1>", self._on_roi_mouse_down)
        self.roi_canvas.bind("<B1-Motion>", self._on_roi_mouse_drag)
        self.roi_canvas.bind("<ButtonRelease-1>", self._on_roi_mouse_up)

        button_frame = ttk.Frame(self.roi_window)
        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=10)

        ttk.Button(
            button_frame,
            text="确定",
            command=self._confirm_roi_selection
        ).pack(side=tk.RIGHT, padx=10)

        ttk.Button(
            button_frame,
            text="取消",
            command=self._cancel_roi_selection
        ).pack(side=tk.RIGHT, padx=10)

        self._update_roi_preview()

    def _update_roi_preview(self):
        """更新ROI预览窗口的画面"""
        if not hasattr(self, 'roi_window') or not self.roi_window.winfo_exists():
            return

        with self.camera_lock:
            ret, frame = self.cap.read()

        if ret and frame is not None:
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(rgb_frame)
            self.roi_photo = ImageTk.PhotoImage(image=img)

            self.roi_canvas.delete("all")  # 清除画布
            self.roi_canvas.create_image(0, 0, image=self.roi_photo, anchor=tk.NW)

            if self.roi_start and self.roi_end:
                x1, y1 = self.roi_start
                x2, y2 = self.roi_end
                if self.roi_rect:
                    self.roi_canvas.delete(self.roi_rect)
                self.roi_rect = self.roi_canvas.create_rectangle(
                    x1, y1, x2, y2, outline="red", width=2
                )

        self.roi_window.after(30, self._update_roi_preview)

    def _on_roi_mouse_down(self, event):
        """鼠标按下事件处理"""
        self.roi_start = (event.x, event.y)
        self.roi_end = None
        if self.roi_rect:
            self.roi_canvas.delete(self.roi_rect)
            self.roi_rect = None

    def _on_roi_mouse_drag(self, event):
        """鼠标拖动事件处理"""
        if self.roi_start:
            self.roi_end = (event.x, event.y)
            if self.roi_rect:
                self.roi_canvas.delete(self.roi_rect)

            x1, y1 = self.roi_start
            x2, y2 = self.roi_end
            self.roi_rect = self.roi_canvas.create_rectangle(
                x1, y1, x2, y2, outline="red", width=2
            )

    def _on_roi_mouse_up(self, event):
        """鼠标释放事件处理"""
        if self.roi_start:
            self.roi_end = (event.x, event.y)

    def _confirm_roi_selection(self):
        """确认ROI选择"""
        if self.roi_start and self.roi_end:
            x1, y1 = self.roi_start
            x2, y2 = self.roi_end

            x = min(x1, x2)
            y = min(y1, y2)
            w = abs(x2 - x1)
            h = abs(y2 - y1)

            if w < 50 or h < 50:
                messagebox.showwarning("提示", "选择的区域太小，请选择更大的区域")
                return

            self.hand_detection_regions = [(x, y, w, h)]
            self.update_status(f"已设置书写区域: ({x}, {y}, {w}, {h})")
            self.logger.info(f"书写区域已设置: ({x}, {y}, {w}, {h})")

            self.roi_window.destroy()
        else:
            messagebox.showwarning("提示", "请先选择一个区域")

    def _cancel_roi_selection(self):
        """取消ROI选择"""
        self.roi_window.destroy()
    def setup_detection_region(self):
        """设置默认的手部检测区域"""
        # 默认区域为画面中心的矩形
        if self.width and self.height:
            x = int(self.width * 0.25)
            y = int(self.height * 0.5)
            w = int(self.width * 0.5)
            h = int(self.height * 0.3)
            self.hand_detection_regions = [(x, y, w, h)]

    def toggle_hand_detection(self):
        """切换手部检测状态"""
        self.hand_detection_enabled = self.hand_detection_var.get()
        status = "启用" if self.hand_detection_enabled else "禁用"
        self.update_status(f"手部检测已{status}")

    def toggle_subject_detection(self):
        """切换学科识别状态"""
        self.subject_detection_enabled = self.subject_detection_var.get()
        status = "启用" if self.subject_detection_enabled else "禁用"
        self.update_status(f"学科识别已{status}")

    def load_face_detectors(self):
        """加载人脸和眼睛检测器"""
        try:
            # 尝试加载预训练的OpenCV分类器
            face_cascade_path = cv2.data.haarcascades + 'haarcascade_frontalface_default.xml'
            eye_cascade_path = cv2.data.haarcascades + 'haarcascade_eye.xml'

            self.face_cascade = cv2.CascadeClassifier(face_cascade_path)
            self.eye_cascade = cv2.CascadeClassifier(eye_cascade_path)

            if self.face_cascade.empty() or self.eye_cascade.empty():
                raise RuntimeError("无法加载人脸或眼睛检测器")

            self.logger.info("人脸和眼睛检测器已成功加载")
        except Exception as e:
            self.logger.error(f"加载人脸检测器时出错: {e}")
            self.face_cascade = None
            self.eye_cascade = None
            messagebox.showerror("错误", f"无法加载人脸检测器: {e}")

    def check_idle_alert(self):
        """检查是否需要发出提醒"""
        current_time = time.time()

        with self.time_lock:
            if self.studying:
                if self.current_session_start is None:
                    self.current_session_start = current_time
                    self.log_alert("开始学习")

                self.study_duration = current_time - self.current_session_start
                self.total_study_time += (current_time - self.last_alert_check_time)
            else:
                if self.current_session_start is not None:
                    # 保存学习会话
                    session_duration = current_time - self.current_session_start
                    session_info = {
                        "start_time": datetime.fromtimestamp(self.current_session_start).strftime("%Y-%m-%d %H:%M:%S"),
                        "end_time": datetime.fromtimestamp(current_time).strftime("%Y-%m-%d %H:%M:%S"),
                        "duration": int(session_duration),
                        "subject": self.current_subject
                    }
                    self.study_sessions.append(session_info)
                    self.log_alert(f"停止学习 (持续时间: {int(session_duration)}秒)")
                    self.current_session_start = None

                self.idle_duration = current_time - self.last_study_time

        # 更新未学习时间显示
        if hasattr(self, 'idle_time_var'):
            minutes, seconds = divmod(int(self.idle_duration), 60)
            self.idle_time_var.set(f"{minutes:02d}:{seconds:02d}")

        # 检查是否需要提醒
        if not self.studying and self.idle_duration >= self.alert_threshold:
            time_since_last_alert = current_time - self.last_alert_time
            if time_since_last_alert >= self.message_interval:
                self.last_alert_time = current_time
                self.show_idle_alert()

    def show_idle_alert(self):
        """显示未学习提醒"""
        minutes, seconds = divmod(int(self.idle_duration), 60)

        try:
            # 尝试播放提醒声音
            if not pygame.mixer.get_init():
                pygame.mixer.init()

            if os.path.exists("alert.wav"):
                pygame.mixer.music.load("alert.wav")
                pygame.mixer.music.play()
        except Exception as e:
            self.logger.warning(f"播放提醒声音失败: {e}")

        dialog = tk.Toplevel(self.root)
        dialog.title("学习提醒")
        dialog.geometry("400x200")
        dialog.resizable(False, False)
        dialog.transient(self.root)
        dialog.attributes("-topmost", True)

        frame = ttk.Frame(dialog, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(
            frame,
            text=f"你已经{minutes}分钟{seconds}秒没有学习了！",
            font=("Arial", 14, "bold")
        ).pack(pady=20)

        ttk.Label(
            frame,
            text="请继续专注学习，保持良好的学习习惯！",
            font=("Arial", 12)
        ).pack(pady=10)

        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(
            button_frame,
            text="知道了",
            command=dialog.destroy
        ).pack(side=tk.RIGHT, padx=5)

        self.log_alert(f"提醒: 已{minutes}分钟{seconds}秒未学习")

    def log_alert(self, message):
        """记录提醒消息"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}"
        self.alert_messages.append(log_message)

        if len(self.alert_messages) > self.max_alert_history:
            self.alert_messages.pop(0)

        self.update_alert_history()
        self.logger.info(log_message)

    def update_alert_history(self):
        """更新提醒历史显示"""
        if hasattr(self, 'alert_text'):
            self.alert_text.config(state=tk.NORMAL)
            self.alert_text.delete(1.0, tk.END)
            for message in self.alert_messages:
                self.alert_text.insert(tk.END, message + "\n")
            self.alert_text.config(state=tk.DISABLED)

    def update_status(self, message):
        """更新状态消息"""
        if hasattr(self, 'status_var'):
            self.status_var.set(message)
            self.logger.info(message)

    def setup_styles(self):
        """设置GUI样式"""
        style = ttk.Style()

        style.configure("TFrame", background="#f0f0f0")
        style.configure("TLabel", background="#f0f0f0", font=("Arial", 10))
        style.configure("TButton", font=("Arial", 10))
        style.configure("TRadiobutton", background="#f0f0f0", font=("Arial", 10))
        style.configure("TCheckbutton", background="#f0f0f0", font=("Arial", 10))

        style.configure("Title.TLabel", font=("Arial", 16, "bold"), foreground="#333333")

        style.configure("Stats.TFrame", background="#e0e0e0")
        style.configure("Stats.TLabel", background="#e0e0e0", font=("Arial", 12))

        style.configure("Accent.TButton", font=("Arial", 10, "bold"), foreground="#ffffff", background="#4a86e8")
        style.map("Accent.TButton",
                  foreground=[('pressed', '#ffffff'), ('active', '#ffffff')],
                  background=[('pressed', '!disabled', '#3a76d8'), ('active', '#5a96f8')])

    def create_gui(self):
        """创建GUI界面"""
        self.root = tk.Tk()
        self.root.title("儿童学习监控系统")
        self.root.geometry("900x600")
        self.root.resizable(True, True)

        main_frame = ttk.Frame(self.root, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(
            title_frame,
            text="儿童学习监控系统",
            style="Title.TLabel"
        ).pack(side=tk.LEFT, padx=5)

        status_frame = ttk.Frame(main_frame)
        status_frame.pack(fill=tk.X, pady=(0, 10))

        self.status_var = tk.StringVar()
        self.status_var.set("系统已启动")

        ttk.Label(
            status_frame,
            textvariable=self.status_var,
            font=("Arial", 10)
        ).pack(side=tk.LEFT, padx=5)

        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)

        camera_frame = ttk.LabelFrame(content_frame, text="摄像头预览")
        camera_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))

        self.camera_label = ttk.Label(camera_frame)
        self.camera_label.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        control_frame = ttk.LabelFrame(content_frame, text="控制面板")
        control_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=(0, 10))

        camera_control_frame = ttk.LabelFrame(control_frame, text="摄像头设置")
        camera_control_frame.pack(fill=tk.X, padx=5, pady=5)

        camera_select_frame = ttk.Frame(camera_control_frame)
        camera_select_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(camera_select_frame, text="选择摄像头:").pack(side=tk.LEFT, padx=5)

        self.camera_combo = ttk.Combobox(camera_select_frame, state="readonly")
        self.camera_combo.pack(side=tk.LEFT, padx=5)

        if self.available_cameras:
            camera_options = [f"摄像头 {i}" for i in self.available_cameras]
            self.camera_combo['values'] = camera_options
            self.camera_combo.current(0)

        ttk.Button(
            camera_select_frame,
            text="连接",
            command=lambda: self.connect_camera(self.available_cameras[self.camera_combo.current()])
        ).pack(side=tk.LEFT, padx=5)

        function_frame = ttk.LabelFrame(control_frame, text="功能控制")
        function_frame.pack(fill=tk.X, padx=5, pady=5)

        function_button_frame = ttk.Frame(function_frame)
        function_button_frame.pack(fill=tk.X, padx=5, pady=5)

        self.start_button = ttk.Button(
            function_button_frame,
            text="开始监控",
            style="Accent.TButton",
            command=self.toggle_monitoring
        )
        self.start_button.pack(side=tk.LEFT, padx=5)

        ttk.Button(
            function_button_frame,
            text="设置书写区域",
            command=self.select_detection_region
        ).pack(side=tk.LEFT, padx=5)

        ttk.Button(
            function_button_frame,
            text="选择学科",
            command=self.select_subject
        ).pack(side=tk.LEFT, padx=5)

        hand_detection_frame = ttk.Frame(function_frame)
        hand_detection_frame.pack(fill=tk.X, padx=5, pady=5)

        self.hand_detection_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            hand_detection_frame,
            text="启用手部检测",
            variable=self.hand_detection_var,
            command=self.toggle_hand_detection
        ).pack(side=tk.LEFT, padx=5)

        subject_frame = ttk.Frame(function_frame)
        subject_frame.pack(fill=tk.X, padx=5, pady=5)

        self.subject_detection_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(
            subject_frame,
            text="启用学科识别",
            variable=self.subject_detection_var,
            command=self.toggle_subject_detection
        ).pack(side=tk.LEFT, padx=5)

        stats_frame = ttk.LabelFrame(control_frame, text="学习统计")
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        current_status_frame = ttk.Frame(stats_frame)
        current_status_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(current_status_frame, text="当前状态:").pack(side=tk.LEFT, padx=5)

        self.status_display = ttk.Label(current_status_frame, text="未监控", foreground="red")
        self.status_display.pack(side=tk.LEFT, padx=5)

        study_time_frame = ttk.Frame(stats_frame)
        study_time_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(study_time_frame, text="今日学习时长:").pack(side=tk.LEFT, padx=5)

        self.study_time_var = tk.StringVar()
        self.study_time_var.set("00:00:00")
        ttk.Label(
            study_time_frame,
            textvariable=self.study_time_var,
            font=("Arial", 12, "bold")
        ).pack(side=tk.LEFT, padx=5)

        # 添加未学习时间显示
        idle_time_frame = ttk.Frame(stats_frame)
        idle_time_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(idle_time_frame, text="未学习时间:").pack(side=tk.LEFT, padx=5)

        self.idle_time_var = tk.StringVar()
        self.idle_time_var.set("00:00")
        ttk.Label(
            idle_time_frame,
            textvariable=self.idle_time_var,
            font=("Arial", 12, "bold")
        ).pack(side=tk.LEFT, padx=5)

        subject_frame = ttk.Frame(stats_frame)
        subject_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(subject_frame, text="当前学科:").pack(side=tk.LEFT, padx=5)

        self.subject_var = tk.StringVar()
        self.subject_var.set("未选择")
        ttk.Label(
            subject_frame,
            textvariable=self.subject_var,
            font=("Arial", 12)
        ).pack(side=tk.LEFT, padx=5)

        history_frame = ttk.LabelFrame(control_frame, text="学习历史")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        self.alert_text = scrolledtext.ScrolledText(history_frame, wrap=tk.WORD, height=5)
        self.alert_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.alert_text.config(state=tk.DISABLED)

        bottom_frame = ttk.Frame(main_frame)
        bottom_frame.pack(fill=tk.X, pady=10)

        ttk.Button(
            bottom_frame,
            text="查看学习分析",
            command=self.analyze_study_patterns
        ).pack(side=tk.RIGHT, padx=5)

        ttk.Button(
            bottom_frame,
            text="退出",
            command=self.quit_application
        ).pack(side=tk.RIGHT, padx=5)

        self.update_gui()

        self.root.protocol("WM_DELETE_WINDOW", self.quit_application)

    def update_gui(self):
        """更新GUI显示"""
        if not self.root.winfo_exists():
            return

        # 更新摄像头预览
        if self.is_capturing and not self.frame_queue.empty():
            try:
                frame = self.frame_queue.get_nowait()

                display_frame = frame.copy()

                # 检测人脸
                display_frame = self.detect_person(display_frame)

                # 检测书写动作
                if self.hand_detection_var.get():
                    display_frame = self.detect_writing(display_frame)

                # 识别学科
                if self.subject_detection_var.get():
                    self.identify_subject(display_frame)

                # 更新学科显示
                self.subject_var.set(self.current_subject if self.current_subject else "未识别")

                # 调整图像大小以适应显示区域
                max_width = self.camera_label.winfo_width()
                max_height = self.camera_label.winfo_height()

                if max_width > 10 and max_height > 10:
                    h, w = display_frame.shape[:2]
                    width_scale = max_width / w
                    height_scale = max_height / h
                    scale = min(width_scale, height_scale)

                    if scale < 1:
                        new_size = (int(w * scale), int(h * scale))
                        display_frame = cv2.resize(display_frame, new_size)

                # 转换为RGB格式
                rgb_frame = cv2.cvtColor(display_frame, cv2.COLOR_BGR2RGB)

                # 转换为PhotoImage
                img = Image.fromarray(rgb_frame)
                self.photo = ImageTk.PhotoImage(image=img)

                # 更新显示
                self.camera_label.config(image=self.photo)

                # 更新状态显示
                status_text = "学习中" if self.studying else "未学习"
                status_color = "green" if self.studying else "red"
                self.status_display.config(text=status_text, foreground=status_color)

                # 更新学习时长显示
                with self.time_lock:
                    total_seconds = int(self.total_study_time)
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    self.study_time_var.set(f"{hours:02d}:{minutes:02d}:{seconds:02d}")

            except Exception as e:
                self.logger.error(f"更新GUI时出错: {e}")

        # 继续更新
        self.root.after(30, self.update_gui)

    def toggle_monitoring(self):
        """切换监控状态"""
        if self.is_capturing:
            self.stop_capture()
            self.start_button.config(text="开始监控")
            self.update_status("监控已停止")
            self.status_display.config(text="未监控", foreground="red")
        else:
            if not self.cap or not self.cap.isOpened():
                if not self.connect_camera():
                    return

            self.start_capture()
            self.start_button.config(text="停止监控")
            self.update_status("监控已开始")
            self.status_display.config(text="监控中", foreground="blue")

    def analyze_study_patterns(self):
        """分析学习模式"""
        if not self.study_sessions:
            messagebox.showinfo("学习分析", "暂无学习数据可供分析")
            return

        # 保存当前会话（如果有）
        if self.current_session_start is not None:
            current_time = time.time()
            session_duration = current_time - self.current_session_start
            session_info = {
                "start_time": datetime.fromtimestamp(self.current_session_start).strftime("%Y-%m-%d %H:%M:%S"),
                "end_time": datetime.fromtimestamp(current_time).strftime("%Y-%m-%d %H:%M:%S"),
                "duration": int(session_duration),
                "subject": self.current_subject
            }
            self.study_sessions.append(session_info)

        # 计算总学习时间
        total_study_seconds = sum(session['duration'] for session in self.study_sessions)
        total_hours, remainder = divmod(total_study_seconds, 3600)
        total_minutes, total_seconds = divmod(remainder, 60)

        # 按学科统计
        subject_stats = {}
        for session in self.study_sessions:
            subject = session['subject']
            if subject not in subject_stats:
                subject_stats[subject] = 0
            subject_stats[subject] += session['duration']

        # 找出学习时间最长的学科
        if subject_stats:
            most_studied_subject = max(subject_stats, key=subject_stats.get)
            most_studied_time = subject_stats[most_studied_subject]
            most_hours, most_remainder = divmod(most_studied_time, 3600)
            most_minutes, most_seconds = divmod(most_remainder, 60)
        else:
            most_studied_subject = "未分类"
            most_hours = most_minutes = most_seconds = 0

        # 学习会话次数
        session_count = len(self.study_sessions)

        # 平均会话时长
        if session_count > 0:
            avg_session_seconds = total_study_seconds / session_count
            avg_hours, avg_remainder = divmod(int(avg_session_seconds), 3600)
            avg_minutes, avg_seconds = divmod(avg_remainder, 60)
        else:
            avg_hours = avg_minutes = avg_seconds = 0

        # 创建分析窗口
        analysis_window = tk.Toplevel(self.root)
        analysis_window.title("学习分析")
        analysis_window.geometry("600x400")
        analysis_window.resizable(False, False)
        analysis_window.transient(self.root)

        frame = ttk.Frame(analysis_window, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(
            frame,
            text="学习分析报告",
            font=("Arial", 14, "bold")
        ).pack(pady=10)

        ttk.Label(
            frame,
            text=f"总学习时长: {total_hours:02d}小时{total_minutes:02d}分钟{total_seconds:02d}秒",
            font=("Arial", 12)
        ).pack(pady=5, anchor=tk.W)

        ttk.Label(
            frame,
            text=f"学习会话次数: {session_count}次",
            font=("Arial", 12)
        ).pack(pady=5, anchor=tk.W)

        ttk.Label(
            frame,
            text=f"平均会话时长: {avg_hours:02d}小时{avg_minutes:02d}分钟{avg_seconds:02d}秒",
            font=("Arial", 12)
        ).pack(pady=5, anchor=tk.W)

        ttk.Label(
            frame,
            text=f"学习时间最长的学科: {most_studied_subject} ({most_hours:02d}小时{most_minutes:02d}分钟{most_seconds:02d}秒)",
            font=("Arial", 12)
        ).pack(pady=5, anchor=tk.W)

        ttk.Label(
            frame,
            text="学科分布:",
            font=("Arial", 12, "bold")
        ).pack(pady=10, anchor=tk.W)

        subject_frame = ttk.Frame(frame)
        subject_frame.pack(fill=tk.BOTH, expand=True)

        # 创建学科分布表格
        subject_tree = ttk.Treeview(subject_frame, columns=("subject", "time"), show="headings")
        subject_tree.heading("subject", text="学科")
        subject_tree.heading("time", text="学习时长")
        subject_tree.column("subject", width=200)
        subject_tree.column("time", width=150)
        subject_tree.pack(fill=tk.BOTH, expand=True)

        for subject, duration in sorted(subject_stats.items(), key=lambda x: x[1], reverse=True):
            hours, remainder = divmod(duration, 3600)
            minutes, seconds = divmod(remainder, 60)
            subject_tree.insert("", tk.END, values=(subject, f"{hours:02d}小时{minutes:02d}分钟{seconds:02d}秒"))

        button_frame = ttk.Frame(analysis_window)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(
            button_frame,
            text="关闭",
            command=analysis_window.destroy
        ).pack(side=tk.RIGHT, padx=10)

    def load_study_data(self):
        """加载历史学习数据"""
        try:
            # 这里应该从文件或数据库加载历史数据
            # 简化版本，实际应用中应实现持久化存储
            self.logger.info("加载历史学习数据")
            # 示例数据
            today = datetime.now().strftime("%Y-%m-%d")
            self.daily_study_data[today] = {
                "total_time": 0,
                "sessions": []
            }
        except Exception as e:
            self.logger.error(f"加载学习数据时出错: {e}")
            self.daily_study_data = {}

    def save_study_data(self):
        """保存学习数据"""
        try:
            # 这里应该将数据保存到文件或数据库
            # 简化版本，实际应用中应实现持久化存储
            self.logger.info("保存学习数据")
        except Exception as e:
            self.logger.error(f"保存学习数据时出错: {e}")

    def quit_application(self):
        """安全退出应用程序"""
        if messagebox.askyesno("退出", "确定要退出儿童学习监控系统吗？"):
            self.update_status("正在退出系统...")

            # 停止捕获
            self.stop_capture()

            # 释放摄像头
            self.release_camera()

            # 保存学习数据
            self.save_study_data()

            # 关闭所有窗口
            if hasattr(self, 'roi_window') and self.roi_window and self.roi_window.winfo_exists():
                self.roi_window.destroy()

            if hasattr(self, 'camera_window') and self.camera_window and self.camera_window.winfo_exists():
                self.camera_window.destroy()

            # 退出应用
            self.root.after(100, self.root.destroy)
            self.logger.info("系统已成功退出")

    def run(self):
        """运行应用程序主循环"""
        self.root.mainloop()


if __name__ == "__main__":
    app = StudyMonitor()
    app.run()
